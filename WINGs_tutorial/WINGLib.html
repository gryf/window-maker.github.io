<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0072)WINGLib.html -->
<html lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>3 Steps to Make a WINGs User Interface</title>
<meta http-equiv="Content-Type" content="text/html"> 
<meta name="keywords" content="WINGs, wraster, widget library, GUI, Window Maker, Unix, Linux">
<meta name="description" content="WINGs/wraster library description">
<meta name="license" content="GNU Free Documentation License">
</head>

<body>
<table align="JUSTIFY" width="100%"><tbody><tr><td align="LEFT"><a href="WINGMenu.html">LAST: Programming Details 3</a></td><td align="RIGHT"><a href="WINGtoc.html">Contents</a></td></tr></tbody></table>


<h4><a name="WidgetList">Library description: List of Widgets and Sample Code</a></h4>
<p>This section lists the prototypes of all the WINGs and a few libwraster functions, some of them with a coding example.

</p><h5>General widgets</h5>
<ul>
<li><code> void WMDestroyWidget (WMWidget *widget) </code>
</li><li><code> void WMMapWidget (WMWidget *w) </code>
</li><li><code> void WMMoveWidget (WMWidget *w, int x, int y) </code>
</li><li><code> void WMRealizeWidget (WMWidget *w) </code>
</li><li><code> void WMRedisplayWidget (WMWidget *w) </code>
</li><li><code> void WMResizeWidget (WMWidget *w, unsigned int width, unsigned int height) </code>
</li><li><code> void WMSetWidgetBackgroundColor (WMWidget *w, WMColor *color) </code>
</li><li><code> void WMUnmapWidget (WMWidget *w) </code>
</li><li><code> void WMUnmapSubwidgets (WMWidget *w)</code>
</li><li><code> unsigned int WMWidgetHeight (WMWidget *w) </code>
</li><li><code> unsigned int WMWidgetWidth (WMWidget *w) </code>
</li><li><code> Bool WMWidgetIsMapped (WMWidget *w) </code>
</li><li><code> WMWidget * WMWidgetOfView (WMView *view) </code>
</li><li><code> WMScreen * WMWidgetScreen (WMWidget *w) </code>
</li></ul><ul>
<li><code> void WMLowerWidget (WMWidget *w) </code>
</li><li><code> void WMRaiseWidget (WMWidget *w) </code>
</li><li><code> void WMReparentWidget (WMWidget *w, WMWidget *newParent, int x, int y) </code>
</li><li><code> void WMSetFocusToWidget (WMWidget *widget) </code>
</li><li><code> void WMSetWidgetDefaultBoldFont (WMScreen *scr, WMFont *font) </code>
</li><li><code> void WMSetWidgetDefaultFont (WMScreen *scr, WMFont *font) </code>
</li><li><code> Window WMWidgetXID (WMWidget *w) </code>
</li><li><code> WMColor * WMGetWidgetBackgroundColor (WMWidget *w) </code>
</li></ul>
<h5><a name="Frames">Frames</a></h5>
A frame can be used to group widgets. When moving widgets, their position will be calculated with respect to the upper left corner of their parent frame. A frame has a WMView. Title position definitions are <a href="WINGLib.html#TitlePositions">here</a>. WMReliefType WMFlat will make the frame's border invisible.
<ul><li><code>WMFrame * WMCreateFrame (WMWidget *parent)</code>
</li><li><code>void WMSetFrameTitle (WMFrame *fPtr, char *title)</code>
</li><li><code> void WMSetFrameTitlePosition (WMFrame *fPtr,
                                     WMTitlePosition position)</code>
</li><li><code> void WMSetFrameRelief (WMFrame *fPtr,
                              WMReliefType relief)</code>
</li></ul>


<h5>Panels</h5>
<ul>
<li><code> WMWindow * WMCreatePanelForWindow (WMWindow *owner, char *name) </code>
</li><li><code> WMWindow * WMCreatePanelWithStyleForWindow (WMWindow *owner, char *name, int style) </code>
</li><li><code> WMGenericPanel * WMCreateGenericPanel (WMScreen *scrPtr, WMWindow *owner, char *title, char *defaultButton, char *alternateButton) </code>
</li><li><code> void WMDestroyGenericPanel (WMGenericPanel *panel) </code>
</li><li><code> void WMChangePanelOwner (WMWindow *win, WMWindow *newOwner) </code>
</li></ul>

<h5>Windows</h5>
<ul>

<li><code> WMWindow * WMCreateWindow (WMScreen *screen, char *name) </code>
</li><li><code> WMWindow * WMCreateWindowWithStyle (WMScreen *screen, char *name, int style) </code>
</li><li><code> void WMCloseWindow (WMWindow *win) </code>
</li><li><code> void WMSetWindowCloseAction (WMWindow *win, WMAction *action, void *clientData) </code>
</li><li><code> void WMSetWindowAspectRatio (WMWindow *win, int minX, int minY, int maxX, int maxY) </code>
</li><li><code> void WMSetWindowBaseSize (WMWindow *win, unsigned width, unsigned height) </code>
</li><li><code> void WMSetWindowUserPosition (WMWindow *win, int x, int y) </code>
</li><li><code> void WMSetWindowInitialPosition (WMWindow *win, int x, int y) </code>
</li><li><code> void WMSetWindowMaxSize (WMWindow *win, unsigned width, unsigned height) </code>
</li><li><code> void WMSetWindowMinSize (WMWindow *win, unsigned width, unsigned height) </code>
</li><li><code> void WMSetWindowMiniwindowPixmap (WMWindow *win, WMPixmap *pixmap) </code>
</li><li><code> void WMSetWindowMiniwindowTitle (WMWindow *win, char *title) </code>
</li><li><code> void WMSetWindowLevel (WMWindow *win, int level) </code>
</li><li><code> void WMSetWindowResizeIncrements (WMWindow *win, unsigned wIncr, unsigned hIncr) </code>
</li><li><code> void WMSetWindowTitle (WMWindow *win, char *title) </code>
</li><li><code> void WMSetWindowDocumentEdited (WMWindow *win, Bool flag) </code>
</li></ul>



<h5><a name="Views">Views</a></h5>
<ul>
<li><code> WMPoint WMGetViewPosition (WMView *view) </code>
</li><li><code> WMPoint WMGetViewScreenPosition (WMView *view) </code>
</li><li><code> WMSize WMGetViewSize (WMView *view) </code>
</li><li><code> void WMSetViewExpandsToParent (WMView *view, int leftOffs, int topOffs, int rightOffs, int bottomOffs) </code>
</li><li><code> void WMSetViewNotifySizeChanges (WMView *view, Bool flag) </code>
<ul></ul>
</li><li><code> void WMSetViewDragDestinationProcs (WMView *view, WMDragDestinationProcs *procs) </code>
</li><li><code> void WMSetViewDragSourceProcs (WMView *view, WMDragSourceProcs *procs) </code>
</li><li><code> void WMSetViewNextResponder (WMView *view, WMView *responder) </code></li><li><code> Window WMViewXID (WMView *view)</code>
</li></ul>


<h5>Buttons<img src="./WINGLib_files/Buttons.jpeg" align="right"></h5>
<ul<li><code> WMButton * WMCreateButton (WMWidget *parent, WMButtonType type) </code>
<li><code> WMButton * WMCreateCustomButton (WMWidget *parent, int behaviourMask) </code>
</li><li><code> void WMGroupButtons (WMButton *bPtr, WMButton *newMember) </code>
</li><li><code> void WMSetButtonAction (WMButton *bPtr, WMAction *action, void *clientData) </code>
</li><li><code> void WMSetButtonImage (WMButton *bPtr, WMPixmap *image) </code>
</li><li><code> void WMSetButtonImageDefault (WMButton *bPtr) </code>
</li><li><code> void WMSetButtonImageDimsWhenDisabled (WMButton *bPtr, Bool flag) </code>
</li><li><code> void WMSetButtonImagePosition (WMButton *bPtr, WMImagePosition position) </code>
</li><li><code> void WMSetButtonText (WMButton *bPtr, char *text) </code>
</li><li><code> void WMSetButtonTextAlignment (WMButton *bPtr, WMAlignment alignment) </code>
</li><li><code> void WMSetButtonTextColor (WMButton *bPtr, WMColor *color) </code>
</li><li><code> void WMSetButtonAltImage (WMButton *bPtr, WMPixmap *image) </code>
</li><li><code> void WMSetButtonAltText (WMButton *bPtr, char *text) </code>
</li><li><code> void WMSetButtonAltTextColor (WMButton *bPtr, WMColor *color) </code>
</li><li><code> void WMSetButtonBordered (WMButton *bPtr, int isBordered) </code>
</li><li><code> void WMSetButtonContinuous (WMButton *bPtr, Bool flag) </code>
</li><li><code> void WMSetButtonDisabledTextColor (WMButton *bPtr, WMColor *color) </code>
</li><li><code> void WMSetButtonFont (WMButton *bPtr, WMFont *font) </code>
</li><li><code> void WMSetButtonPeriodicDelay (WMButton *bPtr, float delay, float interval) </code>
</li><li><code> void WMSetButtonEnabled (WMButton *bPtr, Bool flag) </code>
</li><li><code> void WMSetButtonSelected (WMButton *bPtr, int isSelected) </code>
</li><li><code> void WMSetButtonTag (WMButton *bPtr, int tag) </code>
</li><li><code> void WMPerformButtonClick (WMButton *bPtr) </code>
</li><li><code> int WMGetButtonEnabled (WMButton *bPtr) </code>
</li><li><code> int WMGetButtonSelected (WMButton *bPtr) </code>

<p> WMButtonType: <code> WBTMomentaryPush, WBTMomentaryChange,WBTMomentaryLight  WBTPushOnPushOff, WBTOnOff, WBToggle,  WBTSwitch, WBTRadio</code>

</p><h5>Button boxes</h5>
<ul>
<li><code> WMBox * WMCreateBox (WMWidget *parent) </code>
</li><li><code> void WMSetBoxBorderWidth (WMBox *box, unsigned width) </code>
</li><li><code> void WMSetBoxHorizontal (WMBox *box, Bool flag) </code>
</li><li><code> void WMAddBoxSubview (WMBox *bPtr, WMView *view, Bool expand, Bool fill, int minSize, int maxSize, int space) </code>
</li><li><code> void WMRemoveBoxSubview (WMBox *bPtr, WMView *view) </code>
</li><li><code> void WMAddBoxSubviewAtEnd (WMBox *bPtr, WMView *view, Bool expand, Bool fill, int minSize, int maxSize, int space) </code>
</li></ul>
<h5>Expanding and pull-down buttons<img src="./WINGLib_files/PullDown.jpeg" width="26%" align="right"></h5>
A pop-up button shows a list of buttons when it is clicked. Use the <code>WMSetPopUpButtonPullsDown</code> function with boolean true to make it pull down like a menu. When false, the list will shift, and the current item will be under the mouse pointer.<a href="WINGStep2.html#WMAction">WMAction</a> has been described above. To make the list, you create the first Button, and just use <code>WMAddPopUpButtonItem</code> for the next ones. The numbering starts at 0. You do not need to keep pointers to your labels, as there are functions to get the item number, and,with the item number, the label. The action called is the same for the whole menu list.
<ul>
    <li><code> WMPopUpButton * WMCreatePopUpButton (WMWidget *parent) </code>
</li><li><code> WMMenuItem * WMAddPopUpButtonItem (WMPopUpButton *bPtr, char *title) </code>
</li><li><code> WMMenuItem * WMInsertPopUpButtonItem (WMPopUpButton *bPtr, int index, char *title) </code>
</li><li><code> void WMRemovePopUpButtonItem (WMPopUpButton *bPtr, int index) </code>
</li><li><code> void WMSetPopUpButtonAction (WMPopUpButton *bPtr, WMAction *action, void *clientData) </code>
</li><li><code> void WMSetPopUpButtonPullsDown (WMPopUpButton *bPtr, Bool flag) </code>
</li><li><code> void WMSetPopUpButtonText (WMPopUpButton *bPtr, char *text) </code>

</li><li><code> Bool WMGetPopUpButtonEnabled (WMPopUpButton *bPtr) </code>
</li><li><code> char * WMGetPopUpButtonItem (WMPopUpButton *bPtr, int index) </code>
</li><li><code> Bool WMGetPopUpButtonItemEnabled (WMPopUpButton *bPtr, int index) </code>
</li><li><code> WMMenuItem * WMGetPopUpButtonMenuItem (WMPopUpButton *bPtr, int index) </code>
</li><li><code> int WMGetPopUpButtonNumberOfItems (WMPopUpButton *bPtr) </code>
</li><li><code> int WMGetPopUpButtonSelectedItem (WMPopUpButton *bPtr) </code>

</li><li><code> void WMSetPopUpButtonEnabled (WMPopUpButton *bPtr, Bool flag) </code>
</li><li><code> void WMSetPopUpButtonItemEnabled (WMPopUpButton *bPtr, int index, Bool flag) </code>
</li><li><code> void WMSetPopUpButtonSelectedItem (WMPopUpButton *bPtr, int index) </code>
                                         
</li></ul>

<h5>Text Fields
<img src="./WINGLib_files/TextField.jpeg" width="26%" align="right"></h5>A text field is a widget in which the user can type text. Setting it to secure will show asterisks instead of the typed in characters.
<ul>

<li><code> WMTextField * WMCreateTextField (WMWidget *parent) </code>
</li><li><code> void WMDeleteTextFieldRange (WMTextField *tPtr, WMRange range) </code>
</li><li><code> void WMSetTextFieldSecure (WMTextField *tPtr, Bool flag) </code>
</li><li><code> void WMSetTextFieldText (WMTextField *tPtr, char *text) </code>
</li><li><code> char * WMGetTextFieldText (WMTextField *tPtr) </code>
</li><li><code> void WMSetTextFieldBordered (WMTextField *tPtr, Bool bordered) </code>
</li><li><code> void WMInsertTextFieldText (WMTextField *tPtr, char *text, int position) </code>
</li><li><code> void WMSelectTextFieldRange (WMTextField *tPtr, WMRange range) </code>
</li><li><code> void WMSetTextFieldAlignment (WMTextField *tPtr, WMAlignment alignment) </code>
</li><li><code> void WMSetTextFieldBeveled (WMTextField *tPtr, Bool flag) </code>
</li><li><code> void WMSetTextFieldCursorPosition (WMTextField *tPtr, unsigned int position) </code>
</li><li><code> void WMSetTextFieldEditable (WMTextField *tPtr, Bool flag) </code>
</li><li><code> Bool WMGetTextFieldEditable (WMTextField *tPtr) </code>
</li><li><code> void WMSetTextFieldFont (WMTextField *tPtr, WMFont *font) </code>
</li><li><code> WMFont * WMGetTextFieldFont (WMTextField *tPtr) </code>
</li><li><code> void WMSetTextFieldNextTextField (WMTextField *tPtr, WMTextField *next) </code>
</li><li><code> void WMSetTextFieldPrevTextField (WMTextField *tPtr, WMTextField *prev) </code>
</li><li><code> WMTextFieldDelegate * WMGetTextFieldDelegate (WMTextField *tPtr) </code>
</li><li><code> void WMSetTextFieldDelegate (WMTextField *tPtr, WMTextFieldDelegate *delegate) </code>

</li></ul>

<h5>Labels
<img src="./WINGLib_files/Labels.jpeg" width="26%" align="right"></h5>A label displays text in its parent. WRFlat is the relief type which shows the label without a border. WRSunken and WRSimple are other relief types.
<ul>
<li><code> WMLabel * WMCreateLabel (WMWidget *parent) </code>
</li><li><code> void WMSetLabelRelief (WMLabel *lPtr, WMReliefType relief) </code>
</li><li><code> void WMSetLabelText (WMLabel *lPtr, char *text) </code>
</li><li><code> void WMSetLabelTextAlignment (WMLabel *lPtr, WMAlignment alignment) </code>
</li><li><code> void WMSetLabelTextColor (WMLabel *lPtr, WMColor *color) </code>
</li><li><code> void WMSetLabelWraps (WMLabel *lPtr, Bool flag) </code>
</li><li><code> void WMSetLabelFont (WMLabel *lPtr, WMFont *font) </code>
</li><li><code> void WMSetLabelImage (WMLabel *lPtr, WMPixmap *image) </code>
</li><li><code> void WMSetLabelImagePosition (WMLabel *lPtr, WMImagePosition position) </code>
</li><li><code> int WMWidthOfString (WMFont *font, char *text,
                            int length)</code>
</li><li><code>int W_GetTextHeight (WMFont *font, char *text, int width,
                            int wrap)</code>
</li><li><code> WMFont * WMGetLabelFont (WMLabel *lPtr) </code>
</li><li><code> WMPixmap * WMGetLabelImage (WMLabel *lPtr) </code>
</li><li><code> char * WMGetLabelText (WMLabel *lPtr) </code>
</li><li><code> char * WMGetTabViewItemLabel (WMTabViewItem *item) </code>
</li></ul>

<h5>Sliders
<p><img src="./WINGLib_files/Slider.jpeg" width="20%" align="right"></p></h5>
The slider's orientation is set by <code>WMResizeWidget</code>ing it. A continuous slider will pass all the values along the way when it is being changed.
<ul>
<li><code>WMSlider * WMCreateSlider (WMWidget *parent)</code>
</li><li><code>int WMGetSlider[Max|Min[]Value (WMSlider *slider)</code>
</li><li><code>void WMSetSliderAction (WMSlider *slider,
                               WMAction *action, void *data)</code>
</li><li><code> void WMSetSliderContinuous (WMSlider *slider, Bool flag)</code>

</li><li><code>void WMSetSlider[Max|Min|]Value (WMSlider *slider, int value)</code>

</li><li><code> void WMSetSliderKnobThickness (WMSlider *sPtr,
                                      int thickness)</code>
</li><li><code> void WMSetSliderImage (WMSlider *sPtr, WMPixmap *pixmap)</code>
</li></ul>


<h5><img src="./WINGLib_files/scrollview.jpeg" align="right" width="25%">Scrollable views</h5>
This widget can have two scrollbars to navigate the widget inside of it. 
<ul>
<li><code> WMScrollView * WMCreateScrollView (WMWidget *parent) </code>
</li><li><code> void WMSetScrollViewContentView (WMScrollView *sPtr, WMView *view) </code>
</li><li><code> void WMSetScrollViewHasHorizontalScroller (WMScrollView *sPtr, Bool flag) </code>
</li><li><code> void WMSetScrollViewHasVerticalScroller (WMScrollView *sPtr, Bool flag) </code>
</li><li><code> void WMSetScrollViewLineScroll (WMScrollView *sPtr, int amount) </code>
</li><li><code> void WMSetScrollViewPageScroll (WMScrollView *sPtr, int amount) </code>
</li><li><code> void WMSetScrollViewRelief (WMScrollView *sPtr, WMReliefType type) </code>
</li><li><code> void WMResizeScrollViewContent (WMScrollView *sPtr, unsigned int width, unsigned int height) </code>
</li><li><code> void WMScrollViewScrollPoint (WMScrollView *sPtr, WMPoint point) </code>
</li><li><code> WMScroller * WMGetScrollViewHorizontalScroller (WMScrollView *sPtr) </code>
</li><li><code> WMScroller * WMGetScrollViewVerticalScroller (WMScrollView *sPtr) </code>
</li><li><code> WMRect WMGetScrollViewVisibleRect (WMScrollView *sPtr) </code>

</li></ul>

<h5>Message pop-up windows
<img src="./WINGLib_files/AlertPanel.jpeg" width="26%" align="right"></h5><p>A message pop-up window is shown by calling:
<code>int WMRunAlertPanel (WMScreen *scrPtr, WMWindow *owner,  char *messagetophalf, char *messagebottomhalf,   char *defaultButton, char *alternateButton, char *otherButton)</code>
The first argument should be the widget's screen, the second the window we are working in. The last three are labels for three buttons. The default button will return WAPRDefault (0) from the function, if clicked, and is the option selected if the user presses 'enter'. The middle and left button return 1 and -1. Only those buttons are shown whose labels are not <kbd>NULL</kbd>.
</p><ul>
<li><code> WMAlertPanel * WMCreateAlertPanel (WMScreen *scrPtr, WMWindow *owner, char *title, char *msg, char *defaultButton, char *alternateButton, char *otherButton) </code>
</li><li><code> void WMDestroyAlertPanel (WMAlertPanel *panel) </code>
</li></ul>


<h5>Input dialogs
<img src="./WINGLib_files/InputDialog.jpeg" width="26%" align="right"></h5>A pop up which asks for input, with a cancel and OK button, is provided through the self explanatory function:
<code>char * WMRunInputPanel (WMScreen *screen, WMWindow *owner, char *dialogtitle, char *message,char *defaultText, char *okButtontext, char *cancelButtontext)</code>. Cancel returns a null pointer. The <code>defaultText</code> is presented in the text field in the pop-up, and can be changed by the user.
<ul>
<li><code> void WMDestroyInputPanel (WMInputPanel *panel) </code>
</li><li><code> WMInputPanel * WMCreateInputPanel (WMScreen *scrPtr, WMWindow *owner, char *title, char *msg, char *defaultText, char *okButton, char *cancelButton) </code>
</li></ul>

<h5><a name="FileSelect">File selection</a> dialogs<img src="./WINGLib_files/OpenFileDialog.jpeg" width="30%" align="right"></h5>
File selector and file saving dialogs can be called from the WINGs library rightaway. The file selector window allows the user to browse the file system, open a file, and to delete or create a file or directory. To use it, there are three functions:
<ul><li><code> WMOpenPanel * WMGetOpenPanel (WMScreen *screen)</code>
</li><li><code>int WMRunModalFilePanelForDirectory (WMFilePanel *panel, WMWindow *owner,char *initialpath,char *title, char **fileTypes)</code>
</li><li><code>char * WMGetFilePanelFileName (WMFilePanel *panel)</code>
</li><li><code> WMSavePanel * WMGetSavePanel (WMScreen *screen)</code>
</li><li><code> void WMSetFilePanelAccessoryView (WMFilePanel *panel, WMView *view) </code>
</li><li><code> void WMSetFilePanelAutoCompletion (WMFilePanel *panel, Bool flag) </code>
</li><li><code> void WMSetFilePanelCanChooseDirectories (WMFilePanel *panel, Bool flag) </code>
</li><li><code> void WMSetFilePanelCanChooseFiles (WMFilePanel *panel, Bool flag) </code>
</li><li><code> void WMSetFilePanelDirectory (WMFilePanel *panel, char *path) </code></li><li><code> WMView * WMGetFilePanelAccessoryView (WMFilePanel *panel) </code>
</li><li><code> void WMFreeFilePanel (WMFilePanel *panel) </code>
</li></ul>
<p>
To open files there is a struct WMOpenPanel, to close them WMSavePanel. As for the WMView, we take the nature of the Panel as given for now. We just open a pointer to one on the screen we have opened. To open files, the WMOpenPanel pointer is passed to the function <code>WMRunModalFilePanelForDirectory</code>, which makes the file selector pop up. The owner can be set to NULL. initialpath is a string containing the starting directory name. The title is the dialog's title. The dialog has cancel and OK buttons, which make the function return False and True respectively. If True, the selected file name can be retrieved with  <code>WMGetFilePanelFileName (WMFilePanel *panel)</code>. To save files, exactly the same functions are used, with the only difference that you pass a pointer to a WMSavePanel. 

</p><h5><img src="./WINGLib_files/textarea.jpeg" align="right" width="25%"><a name="TextArea">Text Areas</a></h5>
FreezeText and thaw before and after appending will make the appended text appear immediately. 
<ul><li><code>WMText *WMCreateText(WMWidget *parent)</code>
</li><li><code> WMText * WMCreateTextForDocumentType (WMWidget *parent, WMAction *parser, WMAction *writer) </code>
</li><li><code> void WMAppendTextBlock (WMText *tPtr, void *vtb) </code>
</li><li><code> void WMAppendTextStream (WMText *tPtr, char *text) </code>
</li><li><code> void WMFreezeText (WMText *tPtr) </code>
</li><li><code> void WMThawText (WMText *tPtr) </code>
</li><li><code> char * WMGetTextStream (WMText *tPtr) </code>
</li><li><code> void WMPrependTextBlock (WMText *tPtr, void *vtb) </code>
</li><li><code> void WMPrependTextStream (WMText *tPtr, char *text) </code>
</li><li><code> void * WMRemoveTextBlock (WMText *tPtr) </code>
</li><li><code> Bool WMReplaceTextSelection (WMText *tPtr, char *replacement) </code>
</li><li><code> Bool WMScrollText (WMText *tPtr, int amount) </code>
</li><li><code> void WMShowTextRuler (WMText *tPtr, Bool show) </code>
</li><li><code> Bool WMFindInTextStream (WMText *tPtr, char *needle, Bool direction, Bool caseSensitive) </code>
</li><li><code> Bool WMPageText (WMText *tPtr, Bool direction) </code>


</li><li><code> void WMSetTextHasHorizontalScroller (WMText *tPtr, Bool shouldhave) </code>
</li><li><code> void WMSetTextHasRuler (WMText *tPtr, Bool shouldhave) </code>
</li><li><code> void WMSetTextHasVerticalScroller (WMText *tPtr, Bool shouldhave) </code>
</li><li><code> void WMSetTextAlignment (WMText *tPtr, WMAlignment alignment) </code>
</li><li><code> void WMSetTextBackgroundColor (WMText *tPtr, WMColor *color) </code>
</li><li><code> void WMSetTextBackgroundPixmap (WMText *tPtr, WMPixmap *pixmap) </code>
</li><li><code> void WMSetTextBlockProperties (WMText *tPtr, void *vtb, unsigned int first, unsigned int kanji, unsigned int underlined, int script, WMRulerMargins *margins) </code>
</li><li><code> void WMSetTextDefaultColor (WMText *tPtr, WMColor *color) </code>
</li><li><code> void WMSetTextDefaultFont (WMText *tPtr, WMFont *font) </code>
</li><li><code> void WMSetTextDelegate (WMText *tPtr, WMTextDelegate *delegate) </code>
</li><li><code> void WMSetTextEditable (WMText *tPtr, Bool editable) </code>
</li><li><code> void WMSetTextForegroundColor (WMText *tPtr, WMColor *color) </code>
</li><li><code> void WMSetTextIgnoresNewline (WMText *tPtr, Bool ignore) </code>
</li><li><code> void WMSetTextIndentNewLines (WMText *tPtr, Bool indent) </code>
</li><li><code> void WMSetTextRelief (WMText *tPtr, WMReliefType relief) </code>
</li><li><code> void WMSetTextSelectionColor (WMText *tPtr, WMColor *color) </code>
</li><li><code> void WMSetTextSelectionFont (WMText *tPtr, WMFont *font) </code>
</li><li><code> void WMSetTextSelectionUnderlined (WMText *tPtr, int underlined) </code>
</li><li><code> void WMSetTextUsesMonoFont (WMText *tPtr, Bool mono) </code>

</li><li><code> WMColor * WMGetTextDefaultColor (WMText *tPtr) </code>
</li><li><code> WMFont * WMGetTextDefaultFont (WMText *tPtr) </code>
</li><li><code> int WMGetTextEditable (WMText *tPtr) </code>
</li><li><code> Bool WMGetTextIgnoresNewline (WMText *tPtr) </code>
</li><li><code> int WMGetTextInsertType (WMText *tPtr) </code>
</li><li><code> WMArray * WMGetTextObjects (WMText *tPtr) </code>
</li><li><code> Bool WMGetTextRulerShown (WMText *tPtr) </code>
</li><li><code> WMArray * WMGetTextSelectedObjects (WMText *tPtr) </code>
</li><li><code> char * WMGetTextSelectedStream (WMText *tPtr) </code>
</li><li><code> WMColor * WMGetTextSelectionColor (WMText *tPtr) </code>
</li><li><code> WMFont * WMGetTextSelectionFont (WMText *tPtr) </code>
</li><li><code> int WMGetTextSelectionUnderlined (WMText *tPtr) </code>
</li><li><code> Bool WMGetTextUsesMonoFont (WMText *tPtr) </code>
</li></ul>
<ul>
<li><code> void * WMCreateTextBlockWithObject (WMText *tPtr, WMWidget *w, char *description, WMColor *color, unsigned short first, unsigned short extraInfo) </code>
</li><li><code> void * WMCreateTextBlockWithPixmap (WMText *tPtr, WMPixmap *p, char *description, WMColor *color, unsigned short first, unsigned short extraInfo) </code>
</li><li><code> void * WMCreateTextBlockWithText (WMText *tPtr, char *text, WMFont *font, WMColor *color, unsigned short first, unsigned short len) </code>
</li><li><code> void WMDestroyTextBlock (WMText *tPtr, void *vtb) </code>
</li><li><code> void WMGetTextBlockProperties (WMText *tPtr, void *vtb, unsigned int *first, unsigned int *kanji, unsigned int *underlined, int *script, WMRulerMargins *margins) </code>
</li></ul>

<h5>Split windows/views</h5>
<ul>
<li><code> WMSplitView * WMCreateSplitView (WMWidget *parent) </code>
</li><li><code> void WMAddSplitViewSubview (WMSplitView *sPtr, WMView *subview) </code>
</li><li><code> void WMAdjustSplitViewSubviews (WMSplitView *sPtr) </code>
</li><li><code> void WMRemoveSplitViewSubview (WMSplitView *sPtr, WMView *view) </code>
</li><li><code> void WMRemoveSplitViewSubviewAt (WMSplitView *sPtr, int index) </code>
</li><li><code> void WMSetSplitViewConstrainProc (WMSplitView *sPtr, WMSplitViewConstrainProc *proc) </code>
</li><li><code> void WMSetSplitViewVertical (WMSplitView *sPtr, Bool flag) </code>
</li><li><code> int WMGetSplitViewDividerThickness (WMSplitView *sPtr) </code>
</li><li><code> WMView * WMGetSplitViewSubviewAt (WMSplitView *sPtr, int index) </code>
</li><li><code> int WMGetSplitViewSubviewsCount (WMSplitView *sPtr) </code>
</li><li><code> Bool WMGetSplitViewVertical (WMSplitView *sPtr) </code>


</li></ul>


<h5>lists and Property Lists<img src="./WINGLib_files/List.jpeg" width="20%" align="right"></h5>
<p> <code>WMListItem</code> has a member <code>.text</code>, which contains the string added to the list with <code>WMAddListItem</code>. When making a (multiple) selection in the view, the items are added in a WMArray in the order they have been clicked. The <code>WMArray</code> is a dynamic array with functions to retrieve its elements, or the number of elements. WMList provides a <code>WMListSelectionDidChangeNotification</code> event. Sample code using <code>WMAddNotificationObserver</code> to add a function which handles all the selection events:

</p><pre><code>/* global*/
static void listSelectionObserver(void *observer, WMNotification *notification){
WMList *lPtr = (WMList*)WMGetNotificationObject(notification);
WMListItem *item;
int i;

 item =  WMGetFromArray(WMGetListSelectedItems(lPtr),0);  /* 1st selected item */
 i= WMGetArrayItemCount(WMGetListSelectedItems(lPtr)));   /* number of items   */
    
     /* do something */
}
  
     /* in main :    */

WMList *list;
int i;
char text[100];

 list = WMCreateList(window);
 WMSetListAllowMultipleSelection(list, True);
 for (i=0; i&lt;20; i++) {
     sprintf(text, "20 times same item");
     WMAddListItem(list, text);
 }
 WMAddNotificationObserver(listSelectionObserver, NULL/*(observer)*/,
                              WMListSelectionDidChangeNotification, list);
 WMMapSubwidgets(window);
}
</code></pre>
<code>WMSetList[Double]Action</code> specifies a WMAction to do, when a list item is [double]clicked, e.g.
<pre><code>static void doubleClick(WMWidget *self, void *data){
    WMSelectAllListItems((WMList*)self);
}</code></pre>


<p>Functions:

</p><ul>
<li><code> WMList * WMCreateList (WMWidget *parent) </code>
</li><li><code> void WMClearList (WMList *lPtr) </code>
</li><li><code> WMListItem * WMInsertListItem (WMList *lPtr, int row, char *text) </code>
</li><li><code> void WMSelectAllListItems (WMList *lPtr) </code>
</li><li><code> void WMSelectListItem (WMList *lPtr, int row) </code>
</li><li><code> void WMSelectListItemsInRange (WMList *lPtr, WMRange range) </code>
</li><li><code> void WMRemoveListItem (WMList *lPtr, int row) </code>
</li><li><code> void WMSortListItems (WMList *lPtr) </code>
</li><li><code> void WMSortListItemsWithComparer (WMList *lPtr, WMCompareDataProc *func) </code>
</li><li><code> WMListItem * WMGetListItem (WMList *lPtr, int row) </code>
</li><li><code> int WMGetListItemHeight (WMList *lPtr) </code>
</li><li><code> WMArray * WMGetListItems (WMList *lPtr) </code>
</li><li><code> int WMGetListNumberOfRows (WMList *lPtr) </code>
</li><li><code> int WMGetListPosition (WMList *lPtr) </code>
</li><li><code> WMListItem * WMGetListSelectedItem (WMList *lPtr) </code>
</li><li><code> int WMGetListSelectedItemRow (WMList *lPtr) </code>
</li><li><code> WMArray * WMGetListSelectedItems (WMList *lPtr) </code>

</li><li><code> int WMFindRowOfListItemWithTitle (WMList *lPtr, char *title) </code>
</li><li><code> Bool WMListAllowsEmptySelection (WMList *lPtr) </code>
</li><li><code> Bool WMListAllowsMultipleSelection (WMList *lPtr) </code>
</li><li><code> void WMSetListAction (WMList *lPtr, WMAction *action, void *clientData) </code>
</li><li><code> void WMSetListAllowEmptySelection (WMList *lPtr, Bool flag) </code>
</li><li><code> void WMSetListAllowMultipleSelection (WMList *lPtr, Bool flag) </code>
</li><li><code> void WMSetListBottomPosition (WMList *lPtr, int row) </code>
</li><li><code> void WMSetListDoubleAction (WMList *lPtr, WMAction *action, void *clientData) </code>
</li><li><code> void WMSetListPosition (WMList *lPtr, int row) </code>
</li><li><code> void WMSetListSelectionToRange (WMList *lPtr, WMRange range) </code>
</li><li><code> void WMSetListUserDrawItemHeight (WMList *lPtr, unsigned short height) </code>
</li><li><code> void WMSetListUserDrawProc (WMList *lPtr, WMListDrawProc *proc) </code>
</li><li><code> void WMUnselectAllListItems (WMList *lPtr) </code>
</li><li><code> void WMUnselectListItem (WMList *lPtr, int row) </code>

</li></ul>
<ul>
<li><code> WMPropList * WMCreatePropListFromDescription (char *desc) </code>
</li><li><code> WMPropList * WMDeepCopyPropList (WMPropList *plist) </code>
</li><li><code> char * WMGetPropListDescription (WMPropList *plist, Bool indented) </code>
</li><li><code> int WMGetPropListItemCount (WMPropList *plist) </code>
</li><li><code> Bool WMIsPropListEqualTo (WMPropList *plist, WMPropList *other) </code>
</li><li><code> WMPropList * WMReadPropListFromFile (char *file) </code>
</li><li><code> void WMReleasePropList (WMPropList *plist) </code>
</li><li><code> WMPropList * WMRetainPropList (WMPropList *plist) </code>
</li><li><code> WMPropList * WMShallowCopyPropList (WMPropList *plist) </code>
</li><li><code> Bool WMWritePropListToFile (WMPropList *plist, char *path, Bool atomically)</code>

</li><li><code> void WMPLSetCaseSensitive (Bool caseSensitiveness) </code>
 
</li></ul>


<h5>Colour Panels<img src="./WINGLib_files/ColorPanel.jpeg" width="14%" align="right"><p></p></h5>
<ul>
<li><code> WMColorPanel * WMGetColorPanel (WMScreen *scrPtr) </code>
</li><li><code> void WMCloseColorPanel (WMColorPanel *panel) </code>
</li><li><code> void WMFreeColorPanel (WMColorPanel *panel) </code>
</li><li><code> WMColor * WMGetColorPanelColor (WMColorPanel *panel) </code>
</li><li><code> void WMSetColorPanelAction (WMColorPanel *panel, WMAction2 *action, void *data) </code>
</li><li><code> void WMSetColorPanelColor (WMColorPanel *panel, WMColor *color) </code>
</li><li><code> void WMSetColorPanelPickerMode (WMColorPanel *panel, WMColorPanelMode mode) </code>
</li><li><code> void WMShowColorPanel (WMColorPanel *panel) </code>
</li></ul>

<h5>Font Panel<img src="./WINGLib_files/FontPanel.jpeg" width="20%" align="right"><p></p></h5>
<ul>

<li><code> WMFontPanel * WMGetFontPanel (WMScreen *scr) </code>
</li><li><code> WMFont * WMGetFontPanelFont (WMFontPanel *panel) </code>
</li><li><code> char * WMGetFontPanelFontName (WMFontPanel *panel) </code>
</li><li><code> void WMHideFontPanel (WMFontPanel *panel) </code>
</li><li><code> void WMSetFontPanelAction (WMFontPanel *panel, WMAction2 *action, void *data) </code>
</li><li><code> void WMSetFontPanelFont (WMFontPanel *panel, WMFont *font) </code>
</li><li><code> Bool WMSetFontPanelFontName (WMFontPanel *panel, char *fontName) </code>
</li><li><code> void WMShowFontPanel (WMFontPanel *panel) </code>
</li><li><code> void WMFreeFontPanel (WMFontPanel *panel) </code>

</li></ul>

<h5>Tabbed views</h5><img src="./WINGLib_files/2tabs.jpeg" width="26%" align="right">
<p>The label on the tab itself should not be empty, or the tab won't be clickable. The view in the tab takes the view of the inserted widget. A frame expands to the tabbed view it is in. The widgets which go into the tabbed views should have the same parent as the whole TabView widget. Sample code for a TabView containing two tabs, the first with a frame, the second with a label:
</p><pre><code>
/* WMWindow *window created */
int x,y, Width, Height;
WMFrame *frame;
WMLabel *label;
WMTabView *tabview;
WMTabViewItem *tab;

 tabview = WMCreateTabView(window);
 WMMoveWidget(tabview, x, y);
 WMResizeWidget(tabview, Width, Height);
  
 frame = WMCreateFrame(window);
 tab = WMCreateTabViewItemWithIdentifier(0);
 WMSetTabViewItemView(tab, WMWidgetView(frame));
 WMAddItemInTabView(tabview, tab);
 WMSetTabViewItemLabel(tab, "1");

 label = WMCreateLabel(window);
 WMSetLabelText(label, "Text in View");
 WMMapWidget(label);
 tab = WMCreateTabViewItemWithIdentifier(0);
 WMSetTabViewItemView(tab, WMWidgetView(label));
 WMAddItemInTabView(tabview, tab);
 WMSetTabViewItemLabel(tab, "tab 2"); 

 WMMapSubwidgets(window);
</code></pre>
<img src="./WINGLib_files/TabView.jpeg" width="26%" align="right">

<ul>
<li><code> WMTabView * WMCreateTabView (WMWidget *parent) </code>
</li><li><code> WMTabViewItem * WMCreateTabViewItem (int identifier, char *label) </code>
</li><li><code> WMTabViewItem * WMCreateTabViewItemWithIdentifier (int identifier) </code>
</li><li><code> void WMDestroyTabViewItem (WMTabViewItem *item) </code>
</li><li><code> void WMAddItemInTabView (WMTabView *tPtr, WMTabViewItem *item) </code>
</li><li><code> WMTabViewItem * WMAddTabViewItemWithView (WMTabView *tPtr, WMView *view, int identifier, char *label) </code>
</li><li><code> void WMInsertItemInTabView (WMTabView *tPtr, int index, WMTabViewItem *item) </code>
</li><li><code> void WMRemoveTabViewItem (WMTabView *tPtr, WMTabViewItem *item) </code>
</li><li><code> void WMSetTabViewItemView (WMTabViewItem *item, WMView *view) </code></li><li><code> WMTabViewItem * WMGetSelectedTabViewItem (WMTabView *tPtr) </code>
</li><li><code> int WMGetTabViewItemIdentifier (WMTabViewItem *item) </code>
</li><li><code> char * WMGetTabViewItemLabel (WMTabViewItem *item) </code>
</li><li><code> WMView * WMGetTabViewItemView (WMTabViewItem *item) </code>
</li><li><code> void WMSelectFirstTabViewItem (WMTabView *tPtr) </code>
</li><li><code> void WMSelectLastTabViewItem (WMTabView *tPtr) </code>
</li><li><code> void WMSelectNextTabViewItem (WMTabView *tPtr) </code>
</li><li><code> void WMSelectPreviousTabViewItem (WMTabView *tPtr) </code>
</li><li><code> void WMSelectTabViewItem (WMTabView *tPtr, WMTabViewItem *item) </code>
</li><li><code> void WMSelectTabViewItemAtIndex (WMTabView *tPtr, int index) </code>
</li><li><code> void WMSetTabViewDelegate (WMTabView *tPtr, WMTabViewDelegate *delegate) </code>
</li><li><code> void WMSetTabViewEnabled (WMTabView *tPtr, Bool flag) </code>
</li><li><code> void WMSetTabViewFont (WMTabView *tPtr, WMFont *font) </code>
</li><li><code> void WMSetTabViewItemEnabled (WMTabViewItem *tPtr, Bool flag) </code>
</li><li><code> void WMSetTabViewItemLabel (WMTabViewItem *item, char *label) </code>

</li><li><code> void WMSetTabViewType (WMTabView *tPtr, WMTabViewType type) </code>
</li><li><code> WMTabViewItem * WMTabViewItemAtPoint (WMTabView *tPtr, int x, int y) </code>

</li></ul>

<h5>Progress Indicators<img src="./WINGLib_files/Progress.jpeg" width="20%" align="right"></h5>
<ul>

<li><code> WMProgressIndicator * WMCreateProgressIndicator (WMWidget *parent) </code>
</li><li><code> int WMGetProgressIndicatorMaxValue (WMProgressIndicator *progressindicator) </code>
</li><li><code> int WMGetProgressIndicatorMinValue (WMProgressIndicator *progressindicator) </code>
</li><li><code> int WMGetProgressIndicatorValue (WMProgressIndicator *progressindicator) </code>
</li><li><code> void WMSetProgressIndicatorMaxValue (WMProgressIndicator *progressindicator, int value) </code>
</li><li><code> void WMSetProgressIndicatorMinValue (WMProgressIndicator *progressindicator, int value) </code>
</li><li><code> void WMSetProgressIndicatorValue (WMProgressIndicator *progressindicator, int value) </code>
</li></ul>

<h5>Event handlers</h5>
<ul>
<li><code> void WMCreateEventHandler (WMView *view, unsigned long mask, WMEventProc *eventProc, void *clientData) </code>
</li><li><code> void WMDeleteEventHandler (WMView *view, unsigned long mask, WMEventProc *eventProc, void *clientData) </code>
</li><li><code> int WMHandleEvent (XEvent *event) </code>
</li><li><code> WMEventHook * WMHookEventHandler (WMEventHook *handler) </code>
</li><li><code> void WMMaskEvent (Display *dpy, long mask, XEvent *event) </code>
</li><li><code> void WMNextEvent (Display *dpy, XEvent *event) </code>
</li></ul>
<ul>
<li><code> int XPending(Display *display)</code>
</li></ul>
is a function in libXlib. It returns the number of events in the queue, if needed, after flushing the events buffer. If there are any, WMNextEvent can be called, and next WMHandleEvent.

<h5>Selections</h5>
<ul>
<li><code> Bool WMCreateSelectionHandler (WMView *view, Atom selection, Time timestamp, WMSelectionProcs *procs, void *cdata) </code>
</li><li><code> void WMDeleteSelectionCallback (WMView *view, Atom selection, Time timestamp) </code>
</li><li><code> void WMDeleteSelectionHandler (WMView *view, Atom selection, Time timestamp) </code>
</li><li><code> Bool WMRequestSelection (WMView *view, Atom selection, Atom target, Time timestamp, WMSelectionCallback *callback, void *cdata) </code>

</li></ul>
<h5>Screens</h5>
<ul>

<li><code> WMScreen * WMCreateScreen (Display *display, int screen) </code>
</li><li><code> WMScreen * WMCreateScreenWithRContext (Display *display, int screen, RContext *context) </code>
</li><li><code> WMScreen * WMCreateSimpleApplicationScreen (Display *display) </code>
</li><li><code> WMScreen * WMOpenScreen (const char *display) </code>
</li><li><code> WMPoint WMGetViewScreenPosition (WMView *view) </code>
</li><li><code> int WMScreenDepth (WMScreen *scr) </code>
</li><li><code> Display * WMScreenDisplay (WMScreen *scr) </code>
</li><li><code> unsigned int WMScreenHeight (WMScreen *scr) </code>
</li><li><code> RContext * WMScreenRContext (WMScreen *scr) </code>
</li><li><code> unsigned int WMScreenWidth (WMScreen *scr) </code>
</li><li><code> void WMScreenMainLoop (WMScreen *scr) </code>
</li><li><code> Bool WMScreenPending (WMScreen *scr) </code>
</li></ul>


<h5>Image functions</h5>


<ul>
<li><code>  RImage * WMGetApplicationIconImage (WMScreen *scr)</code>
</li><li><code>WMColor * WMWhiteColor (WMScreen *scr)</code>
</li><li><code>WMColor * WMCreateNamedColor (WMScreen *scr, char *name,
                                      Bool exact)</code>
 </li><li><code>RImage * RCreateImageFromXImage (RContext *context,
                                         XImage *image,
                                         XImage *mask)
  </code></li><li><code><code>   RImage * RCreateImage (unsigned width, unsigned height,
                               int alpha)</code>

</code></li><li><code><code> RImage * RGetImageFromXPMData (RContext *context,
                                       char **data)</code>
</code></li><li><code><code>  RImage * RLoadXPM (RContext *context, char *file,
                           int index)</code>

 </code></li><li><code><code>RContext * RCreateContext (Display *dpy,
                                   int screen_number,
                                   RContextAttributes *attribs)</code>
</code></li><li><code><code>RContext * WMScreenRContext (WMScreen *scr)</code>
</code></li><li><code><code> WMPixmap * WMCreateBlendedPixmapFromFile (WMScreen *scrPtr, char *fileName, RColor *color) </code>
</code></li><li><code><code> WMPixmap * WMCreateBlendedPixmapFromRImage (WMScreen *scrPtr, RImage *image, RColor *color) </code>
</code></li><li><code><code> WMPixmap * WMCreatePixmap (WMScreen *scrPtr, int width, int height, int depth, Bool masked) </code>
</code></li><li><code><code> WMPixmap * WMCreatePixmapFromFile (WMScreen *scrPtr, char *fileName) </code>
</code></li><li><code><code> WMPixmap * WMCreatePixmapFromRImage (WMScreen *scrPtr, RImage *image, int threshold) </code>
</code></li><li><code><code> WMPixmap * WMCreatePixmapFromXPMData (WMScreen *scrPtr, char **data) </code>
</code></li><li><code><code> WMPixmap * WMCreatePixmapFromXPixmaps (WMScreen *scrPtr, Pixmap pixmap, Pixmap mask, int width, int height, int depth) </code>
</code></li><li><code><code> void WMDrawPixmap (WMPixmap *pixmap, Drawable d, int x, int y) </code>
</code></li><li><code><code> Pixmap WMGetPixmapMaskXID (WMPixmap *pixmap) </code>
</code></li><li><code><code> WMSize WMGetPixmapSize (WMPixmap *pixmap) </code>
</code></li><li><code><code> Pixmap WMGetPixmapXID (WMPixmap *pixmap) </code>
</code></li><li><code><code> WMPixmap * WMGetSystemPixmap (WMScreen *scr, int image) </code>
</code></li><li><code><code> void WMReleasePixmap (WMPixmap *pixmap) </code>
</code></li><li><code><code> WMPixmap * WMRetainPixmap (WMPixmap *pixmap) </code>

</code></li></ul><code>

<h5>Application wide functions</h5>

<ul>
<li><code> void WMInitializeApplication (char *applicationName, int *argc, char **argv) </code>
</li><li><code> char * WMGetApplicationName () </code>
</li><li><code> void WMSetApplicationHasAppIcon (WMScreen *scr, Bool flag) </code>
</li><li><code> void WMSetApplicationIconImage (WMScreen *scr, RImage *image) </code>
</li><li><code> void WMSetApplicationIconPixmap (WMScreen *scr, WMPixmap *icon) </code>
</li></ul>
<ul>
<li><code> void WMSetApplicationIconWindow (WMScreen *scr, Window window) </code>
</li><li><code> WMPixmap * WMCreateApplicationIconBlendedPixmap (WMScreen *scr, RColor *color) </code>
</li><li><code> RImage * WMGetApplicationIconImage (WMScreen *scr) </code>
</li><li><code> WMPixmap * WMGetApplicationIconPixmap (WMScreen *scr) </code>
</li></ul>
<hr>

<h5><a name="Notification">Notifications</a></h5>
<p> A typical sequence to have a window handle messages which come from some widget, is:
<br>(global)
<code>const char *WMRequestName="AnyName";</code><br>
At the point (in some widget function) where another window (widget) should act on the notification, put:
<br><code>WMPostNotificationName(WMRequestName, self, NULL);</code><br>
This call will put the notification in a queue.
</p><p>In the <code>WMNotificationObserverAction(void *self,WMNotification notif)</code>, with name "notificationHandler", put
<br><code>if(!strcmp(WMRequestName,WMGetNotificationName(notif))){do something}</code><br>
This will do something if the incoming notification is one with the right name. To put it to work by a widget "window", do:
<br>
<code> WMAddNotificationObserver(notificationHandler, window, WMRequestName, object)</code><br>
Arguments "window" and "object", and also the notification name, can be NULL.
The last argument (object) to the WMAddNotification<wbr>Observer function selects an object where the notification is allowed to come from. To handle all incoming notifications with the right name, set this to NULL
</p><ul>
<li><code> void WMAddNotificationObserver (WMNotificationObserverAction *observerAction, void *observer, const char *name, void *object) </code>
</li><li><code> WMNotification * WMCreateNotification (const char *name, void *object, void *clientData) </code>
</li><li><code> WMNotificationQueue * WMCreateNotificationQueue (void ) </code>
</li><li><code> void WMPostNotification (WMNotification *notification) </code>
</li><li><code> void WMPostNotificationName (const char *name, void *object, void *clientData) </code>
</li><li><code> void * WMGetNotificationClientData (WMNotification *notification) </code>
</li><li><code> const char * WMGetNotificationName (WMNotification *notification) </code>
</li><li><code> void * WMGetNotificationObject (WMNotification *notification) </code>
</li><li><code> void WMEnqueueNotification (WMNotificationQueue *queue, WMNotification *notification, WMPostingStyle postingStyle) </code>
</li><li><code> void WMDequeueNotificationMatching (WMNotificationQueue *queue, WMNotification *notification, unsigned mask) </code>
</li><li><code> void WMEnqueueCoalesceNotification (WMNotificationQueue *queue, WMNotification *notification, WMPostingStyle postingStyle, unsigned coalesceMask) </code>
</li><li><code> WMNotificationQueue * WMGetDefaultNotificationQueue (void ) </code>
</li><li><code> void WMReleaseNotification (WMNotification *notification) </code>
</li><li><code> void WMRemoveNotificationObserver (void *observer) </code>
</li><li><code> void WMRemoveNotificationObserverWithName (void *observer, const char *name, void *object) </code>
</li><li><code> WMNotification * WMRetainNotification (WMNotification *notification) </code>
</li><li><code> void WMSetViewNotifySizeChanges (WMView *view, Bool flag) </code>
</li></ul>

<h5>Text balloons</h5>
<ul>
<li><code> void WMSetBalloonEnabled (WMScreen *scr, Bool flag) </code>
</li><li><code> void WMSetBalloonDelay (WMScreen *scr, int delay) </code>
</li><li><code> void WMSetBalloonFont (WMScreen *scr, WMFont *font) </code>
</li><li><code> void WMSetBalloonTextAlignment (WMScreen *scr, WMAlignment alignment) </code>
</li><li><code> void WMSetBalloonTextColor (WMScreen *scr, WMColor *color) </code>
</li><li><code> void WMSetBalloonTextForView (char *text, WMView *view) </code>
</li><li><code> W_Balloon * W_CreateBalloon (WMScreen *scr)</code>
</li><li><code> void W_BalloonHandle[Enter|Leave]View (WMView *view)</code>
</li></ul>

<h5>Drag/drop functions</h5>
<p>
</p><ul>
<li><code> void WMDragImageFromView (WMView *view, WMPixmap *image, char *dataTypes, WMPoint atLocation, WMSize mouseOffset, XEvent *event, Bool slideBack) </code>
</li><li><code> WMPoint WMGetDraggingInfoImageLocation (WMDraggingInfo *info) </code>
</li><li><code> void WMRegisterViewForDraggedTypes (WMView *view, char *acceptedTypes) </code>
</li><li><code> void WMSetViewDragDestinationProcs (WMView *view, WMDragDestinationProcs *procs) </code>
</li><li><code> void WMSetViewDragSourceProcs (WMView *view, WMDragSourceProcs *procs) </code>
</li><li><code> void WMUnregisterViewDraggedTypes (WMView *view) </code>
</li><li><code> Bool WMRequestDroppedData (WMView *view, WMDraggingInfo *info, char *type, WMDropDataCallback *callback) </code>

</li></ul>

<h5>Network connection</h5>
<ul>

<li><code> WMConnection * WMCreateConnectionAsServerAtAddress (char *host, char *service, char *protocol) </code>
</li><li><code> WMConnection * WMCreateConnectionToAddress (char *host, char *service, char *protocol) </code>
</li><li><code> WMConnection * WMCreateConnectionToAddressAndNotify (char *host, char *service, char *protocol) </code>
</li><li><code> WMConnection * WMAcceptConnection (WMConnection *listener) </code>
</li><li><code> void WMCloseConnection (WMConnection *cPtr) </code>
</li><li><code> void WMDestroyConnection (WMConnection *cPtr) </code>
</li><li><code> void WMSetConnectionClientData (WMConnection *cPtr, void *data) </code>
</li><li><code> Bool WMSetConnectionCloseOnExec (WMConnection *cPtr, Bool flag) </code>
</li><li><code> void WMSetConnectionDefaultTimeout (unsigned int timeout) </code>
</li><li><code> void WMSetConnectionDelegate (WMConnection *cPtr, ConnectionDelegate *delegate) </code>
</li><li><code> void WMSetConnectionFlags (WMConnection *cPtr, unsigned int flags) </code>
</li><li><code> Bool WMSetConnectionNonBlocking (WMConnection *cPtr, Bool flag) </code>
</li><li><code> void WMSetConnectionOpenTimeout (unsigned int timeout) </code>
</li><li><code> void WMSetConnectionSendTimeout (WMConnection *cPtr, unsigned int timeout) </code>
</li><li><code> void WMSetConnectionShutdownOnClose (WMConnection *cPtr, Bool flag) </code>
</li><li><code> Bool WMEnqueueConnectionData (WMConnection *cPtr, WMData *data) </code>
</li><li><code> char * WMGetConnectionAddress (WMConnection *cPtr) </code>
</li><li><code> WMData * WMGetConnectionAvailableData (WMConnection *cPtr) </code>
</li><li><code> void * WMGetConnectionClientData (WMConnection *cPtr) </code>
</li><li><code> unsigned int WMGetConnectionFlags (WMConnection *cPtr) </code>
</li><li><code> char * WMGetConnectionProtocol (WMConnection *cPtr) </code>
</li><li><code> char * WMGetConnectionService (WMConnection *cPtr) </code>
</li><li><code> int WMGetConnectionSocket (WMConnection *cPtr) </code>
</li><li><code> WMConnectionState WMGetConnectionState (WMConnection *cPtr) </code>
</li><li><code> WMConnectionTimeoutState WMGetConnectionTimeoutState (WMConnection *cPtr) </code>
</li><li><code> WMArray * WMGetConnectionUnsentData (WMConnection *cPtr) </code>
</li><li><code> int WMSendConnectionData (WMConnection *cPtr, WMData *data) </code>
</li></ul>

<h5><a name="DrawFunctions">Draw functions</a></h5>
<ul>
<li><code> RContext * RCreateContext (Display *dpy, int screen_number, RContextAttributes *attribs) </code>
</li><li><code> GC WMColorGC (WMColor *color) </code>
</li><li><code> RImage * RCreateImage (unsigned width, unsigned height, int alpha) </code>
</li><li><code> RImage * RCreateImageFromDrawable (RContext *context, Drawable drawable, Pixmap mask) </code>
</li><li><code> RImage * RCreateImageFromXImage (RContext *context, XImage *image, XImage *mask) </code>
</li><li><code> RXImage * RCreateXImage (RContext *context, int depth, unsigned width, unsigned height) </code>
</li><li><code> void RDestroyXImage (RContext *context, RXImage *rximage) </code>
</li><li><code> void RBevelImage (RImage *image, int bevel_type) </code>
</li><li><code> int RBlurImage (RImage *image) </code>
</li><li><code> void RClearImage (RImage *image, RColor *color) </code>
</li><li><code> RImage * RCloneImage (RImage *image) </code>
</li><li><code> int RDrawLine (RImage *image, int x0, int y0, int x1, int y1, RColor *color) </code>
</li><li><code> void RDrawLines (RImage *image, RPoint *points, int npoints, int mode, RColor *color) </code>
</li><li><code> void RDrawSegments (RImage *image, RSegment *segs, int nsegs, RColor *color) </code>
</li><li><code> void RFillImage (RImage *image, RColor *color) </code>
</li><li><code> void RCombineArea (RImage *image, RImage *src, int sx, int sy, unsigned width, unsigned height, int dx, int dy) </code>
</li><li><code> void RCombineAreaWithOpaqueness (RImage *image, RImage *src, int sx, int sy, unsigned width, unsigned height, int dx, int dy, int opaqueness) </code>
</li><li><code> void RCombineImageWithColor (RImage *image, RColor *color) </code>
</li><li><code> void RCombineImages (RImage *image, RImage *src) </code>
</li><li><code> void RCombineImagesWithOpaqueness (RImage *image, RImage *src, int opaqueness) </code>
</li><li><code> int RConvertImage (RContext *context, RImage *image, Pixmap *pixmap) </code>
</li><li><code> int RConvertImageMask (RContext *context, RImage *image, Pixmap *pixmap, Pixmap *mask, int threshold) </code>
</li><li><code> Bool RGetClosestXColor (RContext *context, RColor *color, XColor *retColor) </code>
</li><li><code> char * RGetImageFileFormat (char *file) </code>
</li><li><code> RImage * RGetImageFromXPMData (RContext *context, char **data) </code>
</li><li><code> Bool RGetPixel (RImage *image, int x, int y, RColor *color) </code>
</li><li><code> RImage * RGetSubImage (RImage *image, int x, int y, unsigned width, unsigned height) </code>
</li><li><code> RXImage * RGetXImage (RContext *context, Drawable d, int x, int y, unsigned width, unsigned height) </code>
</li><li><code> void RHSVtoRGB (RHSVColor *hsv, RColor *rgb) </code>
</li><li><code> RImage * RLoadImage (RContext *context, char *file, int index) </code>
</li><li><code> RImage * RLoadPPM (RContext *context, char *file_name, int index) </code>
</li><li><code> RImage * RLoadXPM (RContext *context, char *file, int index) </code>
</li><li><code> RImage * RMakeCenteredImage (RImage *image, unsigned width, unsigned height, RColor *color) </code>
</li><li><code> RImage * RMakeTiledImage (RImage *tile, unsigned width, unsigned height) </code>
</li><li><code> const char * RMessageForError (int errorCode) </code>
</li><li><code> int ROperateLine (RImage *image, int operation, int x0, int y0, int x1, int y1, RColor *color) </code>
</li><li><code> void ROperateLines (RImage *image, int operation, RPoint *points, int npoints, int mode, RColor *color) </code>
</li><li><code> void ROperatePixel (RImage *image, int operation, int x, int y, RColor *color) </code>
</li><li><code> void ROperatePixels (RImage *image, int operation, RPoint *points, int npoints, int mode, RColor *color) </code>
</li><li><code> void ROperateSegments (RImage *image, int operation, RSegment *segs, int nsegs, RColor *color) </code>
</li><li><code> void RPutPixel (RImage *image, int x, int y, RColor *color) </code>
</li><li><code> void RPutPixels (RImage *image, RPoint *points, int npoints, int mode, RColor *color) </code>
</li><li><code> void RPutXImage (RContext *context, Drawable d, GC gc, RXImage *ximage, int src_x, int src_y, int dest_x, int dest_y, unsigned int width, unsigned int height) </code>
</li><li><code> void RRGBtoHSV (RColor *rgb, RHSVColor *hsv) </code>
</li><li><code> void RReleaseImage (RImage *image) </code>
</li><li><code> RImage * RRenderGradient (unsigned width, unsigned height, RColor *from, RColor *to, int style) </code>
</li><li><code> RImage * RRenderInterwovenGradient (unsigned width, unsigned height, RColor colors1, int thickness1, RColor colors2, int thickness2) </code>
</li><li><code> RImage * RRenderMultiGradient (unsigned width, unsigned height, RColor **colors, int style) </code>
</li><li><code> RImage * RRetainImage (RImage *image) </code>
</li><li><code> RImage * RRotateImage (RImage *image, float angle) </code>
</li><li><code> Bool RSaveImage (RImage *image, char *filename, char *format) </code>
</li><li><code> Bool RSaveXPM (RImage *image, char *filename) </code>
</li><li><code> RImage * RScaleImage (RImage *image, unsigned new_width, unsigned new_height) </code>
</li><li><code> RImage * RSmoothScaleImage (RImage *src, unsigned new_width, unsigned new_height) </code>
</li><li><code> char ** RSupportedFileFormats (void ) </code></li><li><code> RColor ulongToRColor (WMScreen *scr, unsigned long value) </code>
</li><li><code>RColor WMGetRColorFromColor(WMColor *color)</code>
</li><li><code>  RColor col = {0xae,0xaa,0xae,0xff}</code>
</li></ul>

<ul>Other used graphics functions which are not libWINGs/libwraster:
<li><code> Status XmuCreateColormap (dpy , colormap ) </code>
</li><li><code> void XmuDeleteStandardColormap (dpy , screen , property ) </code>
</li><li><code> Status XmuGetColormapAllocation (vinfo , property , red_max , green_max , blue_max ) </code>
</li><li><code> Status XmuLookupStandardColormap (dpy , screen , visualid , depth , property , replace , retain ) </code>
</li><li><code> XStandardColormap * XmuStandardColormap (dpy , screen , visualid , depth , property , cmap , red_max , green_max , blue_max ) </code>
</li><li><code>  int XDrawRectangle(Display *display, Drawable d, GC gc,
              int x, int y, unsigned int width, unsigned int
              height)</code></li><li><code>
   int XDrawLines(Display *display, Drawable d, GC gc, XPoint
              *points, int npoints, int mode)</code></li><li><code>

 int XDrawSegments(Display *display, Drawable d, GC gc,
              XSegment *segments, int nsegments)</code></li><li><code>

    int XDrawArc(Display *display, Drawable d, GC gc, int x,
              int y, unsigned int width, unsigned int height, int
              angle1, int angle2)</code></li><li><code>
  int XDrawArcs(Display *display, Drawable d, GC gc, XArc
              *arcs, int narcs)</code></li><li><code>
    int XDrawPoint(Display *display, Drawable d, GC gc, int x,
              int y)</code></li><li><code>

       int XDrawPoints(Display *display, Drawable d, GC gc,
              XPoint *points, int npoints, int mode)</code></li><li><code>

    GC XCreateGC(Display *display, Drawable d, unsigned long
              valuemask, XGCValues *values)</code></li><li><code>
   int XFillArc(Display *display, Drawable d, GC gc, int x,
              int y, unsigned int width, unsigned int height, int
              angle1, int angle2)</code></li><li><code>
       int XFillPolygon(Display *display, Drawable d, GC gc,
              XPoint *points, int npoints, int shape, int mode)</code></li><li><code>


  typedef struct {
            short x1, y1, x2, y2;
       } XSegment</code></li><li><code>

   typedef struct {
            short x, y;
       } XPoint</code></li><li><code>


 typedef struct {
            short x, y;
            unsigned short width, height;
            short angle1, angle2;             /* Degrees * 64 */
       } XArc</code>


</li></ul>

<h5>Browser functions</h5>
<ul>
<li><code> WMBrowser * WMCreateBrowser (WMWidget *parent) </code>
</li><li><code> int WMAddBrowserColumn (WMBrowser *bPtr) </code>
</li><li><code> Bool WMBrowserAllowsEmptySelection (WMBrowser *bPtr) </code>
</li><li><code> Bool WMBrowserAllowsMultipleSelection (WMBrowser *bPtr) </code>
</li><li><code> void WMSetBrowserAction (WMBrowser *bPtr, WMAction *action, void *clientData) </code>
</li><li><code> void WMSetBrowserAllowEmptySelection (WMBrowser *bPtr, Bool flag) </code>
</li><li><code> void WMSetBrowserAllowMultipleSelection (WMBrowser *bPtr, Bool flag) </code>
</li><li><code> void WMSetBrowserColumnTitle (WMBrowser *bPtr, int column, char *title) </code>
</li><li><code> void WMSetBrowserDelegate (WMBrowser *bPtr, WMBrowserDelegate *delegate) </code>
</li><li><code> void WMSetBrowserDoubleAction (WMBrowser *bPtr, WMAction *action, void *clientData) </code>
</li><li><code> void WMSetBrowserHasScroller (WMBrowser *bPtr, int hasScroller) </code>
</li><li><code> void WMSetBrowserMaxVisibleColumns (WMBrowser *bPtr, int columns) </code>
</li><li><code> char * WMSetBrowserPath (WMBrowser *bPtr, char *path) </code>
</li><li><code> void WMSetBrowserPathSeparator (WMBrowser *bPtr, char *separator) </code>
</li><li><code> void WMSetBrowserTitled (WMBrowser *bPtr, Bool flag) </code>
</li><li><code> void WMSortBrowserColumn (WMBrowser *bPtr, int column) </code>
</li><li><code> void WMSortBrowserColumnWithComparer (WMBrowser *bPtr, int column, WMCompareDataProc *func) </code>
</li><li><code> int WMGetBrowserFirstVisibleColumn (WMBrowser *bPtr) </code>
</li><li><code> WMList * WMGetBrowserListInColumn (WMBrowser *bPtr, int column) </code>
</li><li><code> int WMGetBrowserMaxVisibleColumns (WMBrowser *bPtr) </code>
</li><li><code> int WMGetBrowserNumberOfColumns (WMBrowser *bPtr) </code>
</li><li><code> char * WMGetBrowserPath (WMBrowser *bPtr) </code>
</li><li><code> char * WMGetBrowserPathToColumn (WMBrowser *bPtr, int column) </code>
</li><li><code> WMArray * WMGetBrowserPaths (WMBrowser *bPtr) </code>
</li><li><code> int WMGetBrowserSelectedColumn (WMBrowser *bPtr) </code>
</li><li><code> WMListItem * WMGetBrowserSelectedItemInColumn (WMBrowser *bPtr, int column) </code>
</li><li><code> int WMGetBrowserSelectedRowInColumn (WMBrowser *bPtr, int column) </code>
</li><li><code> WMListItem * WMInsertBrowserItem (WMBrowser *bPtr, int column, int row, char *text, Bool isBranch) </code>
</li><li><code> void WMLoadBrowserColumnZero (WMBrowser *bPtr) </code>
</li><li><code> void WMRemoveBrowserItem (WMBrowser *bPtr, int column, int row) </code>
</li></ul>

<h5>Menu items</h5>
<ul>
<li><code> WMMenuItem * WMCreateMenuItem (void ) </code>
</li><li><code> void WMDestroyMenuItem (WMMenuItem *item) </code>
</li><li><code> void WMSetMenuItemAction (WMMenuItem *item, WMAction *action, void *data) </code>
</li><li><code> void WMSetMenuItemEnabled (WMMenuItem *item, Bool flag) </code>
</li><li><code> void WMSetMenuItemMixedStatePixmap (WMMenuItem *item, WMPixmap *pixmap) </code>
</li><li><code> void WMSetMenuItemOffStatePixmap (WMMenuItem *item, WMPixmap *pixmap) </code>
</li><li><code> void WMSetMenuItemOnStatePixmap (WMMenuItem *item, WMPixmap *pixmap) </code>
</li><li><code> void WMSetMenuItemPixmap (WMMenuItem *item, WMPixmap *pixmap) </code>
</li><li><code> void WMSetMenuItemRepresentedObject (WMMenuItem *item, void *object) </code>
</li><li><code> void WMSetMenuItemShortcut (WMMenuItem *item, char *shortcut) </code>
</li><li><code> void WMSetMenuItemShortcutModifierMask (WMMenuItem *item, unsigned mask) </code>
</li><li><code> void WMSetMenuItemState (WMMenuItem *item, int state) </code>
</li><li><code> void WMSetMenuItemTitle (WMMenuItem *item, char *title) </code>
</li><li><code> Bool WMMenuItemIsSeparator (WMMenuItem *item) </code>
</li><li><code> WMAction * WMGetMenuItemAction (WMMenuItem *item) </code>
</li><li><code> void * WMGetMenuItemData (WMMenuItem *item) </code>
</li><li><code> Bool WMGetMenuItemEnabled (WMMenuItem *item) </code>
</li><li><code> WMPixmap * WMGetMenuItemMixedStatePixmap (WMMenuItem *item) </code>
</li><li><code> WMPixmap * WMGetMenuItemOffStatePixmap (WMMenuItem *item) </code>
</li><li><code> WMPixmap * WMGetMenuItemOnStatePixmap (WMMenuItem *item) </code>
</li><li><code> WMPixmap * WMGetMenuItemPixmap (WMMenuItem *item) </code>
</li><li><code> void * WMGetMenuItemRepresentedObject (WMMenuItem *item) </code>
</li><li><code> char * WMGetMenuItemShortcut (WMMenuItem *item) </code>
</li><li><code> unsigned WMGetMenuItemShortcutModifierMask (WMMenuItem *item) </code>
</li><li><code> int WMGetMenuItemState (WMMenuItem *item) </code>
</li><li><code> char * WMGetMenuItemTitle (WMMenuItem *item) </code>
</li><li><code> WMMenuItem * WMGetSeparatorMenuItem (void ) </code>
</li></ul>


<h5>Utility/redefined functions</h5>
<ul>

<li><code> char * wdefaultspathfordomain (char *domain) </code>
</li><li><code> char * wexpandpath (char *path) </code>
</li><li><code> void wfatal (const char *msg, ... ) </code>
</li><li><code> char * wfindfile (char *paths, char *file) </code>
</li><li><code> char * wfindfileinarray (WMPropList *array, char *file) </code>
</li><li><code> char * wfindfileinlist (char **path_list, char *file) </code>
</li><li><code> void wfree (void *ptr) </code>
</li><li><code> char * wgethomedir () </code>
</li><li><code> void * wmalloc (size_t size) </code>
</li><li><code> void wmessage (const char *msg, ... ) </code>
</li><li><code> WMPoint wmkpoint (int x, int y) </code>
</li><li><code> WMRange wmkrange (int start, int count) </code>
</li><li><code> WMSize wmksize (unsigned int width, unsigned int height) </code>
</li><li><code> void * wrealloc (void *ptr, size_t newsize) </code>
</li><li><code> void wrelease (void *ptr) </code>
</li><li><code> void * wretain (void *ptr) </code>
</li><li><code> waborthandler * wsetabort (waborthandler *handler) </code>
</li><li><code> char * wstrappend (char *dst, char *src) </code>
</li><li><code> char * wstrconcat (char *str1, char *str2) </code>
</li><li><code> char * wstrdup (char *str) </code>
</li><li><code> char * wstrerror (int errnum) </code>
</li><li><code> char * wstrndup (char *str, size_t len) </code>
</li><li><code> void wsyserror (const char *msg, ... ) </code>
</li><li><code> void wsyserrorwithcode (int error, const char *msg, ... ) </code>
</li><li><code> void wtokenfree (char **tokens, int count) </code>
</li><li><code> char * wtokenjoin (char **list, int count) </code>
</li><li><code> char * wtokennext (char *word, char **next) </code>
</li><li><code> void wtokensplit (char *command, char ***argv, int *argc) </code>
</li><li><code> char * wtrimspace (char *s) </code>
</li><li><code> char * wusergnusteppath () </code>
</li><li><code> void wwarning (const char *msg, ... ) </code>
</li></ul><small>
Other used functions:<ul>
<li><code> int calculateCombineArea (RImage *des, RImage *src, int *sx, int *sy, int *swidth, int *sheight, int *dx, int *dy) </code>
</li><li><code> void convertCPColor (CPColor *color) </code>
</li><li><code> void destroyNode (void *data) </code>
</li><li><code> void drawClip () </code>
</li><li><code> char * generateNewFilename (char *curName) </code>
</li><li><code> unsigned char getShift (unsigned char value) </code>
</li><li><code> char * getStream (WMText *tPtr, int sel, int array) </code>
</li><li><code> WMArray * getStreamObjects (WMText *tPtr, int sel) </code>
</li><li><code> Pixmap makeMenuPixmap (PopUpButton *bPtr) </code>
</li><li><code> Bool requestDroppedData (WMView *view, WMDraggingInfo *info, char *type) </code>
</li><li><code> WMData * requestHandler (WMView *view, Atom selection, Atom target, void *cdata, Atom *type) </code>
</li><li><code> RColor ulongToRColor (WMScreen *scr, unsigned long value) </code>
</li></ul></small>
<h4>Data types</h4>

<h5>WMColor</h5>
<ul>

<li><code> WMColor * WMCreateNamedColor (WMScreen *scr, char *name, Bool exact) </code>
</li><li><code> WMColor * WMCreateRGBAColor (WMScreen *scr, unsigned short red, unsigned short green, unsigned short blue, unsigned short alpha, Bool exact) </code>
</li><li><code> WMColor * WMCreateRGBColor (WMScreen *scr, unsigned short red, unsigned short green, unsigned short blue, Bool exact) </code>
</li><li><code> void WMReleaseColor (WMColor *color) </code>
</li><li><code> WMColor * WMRetainColor (WMColor *color) </code>
</li><li><code> char * WMGetColorRGBDescription (WMColor *color) </code>

</li><li><code> WMColor * WMBlackColor (WMScreen *scr) </code>
</li><li><code> WMColor * WMWhiteColor (WMScreen *scr) </code>
</li><li><code> WMColor * WMGrayColor (WMScreen *scr) </code>
</li><li><code> WMColor * WMDarkGrayColor (WMScreen *scr) </code>
</li><li><code> unsigned short WMBlueComponentOfColor (WMColor *color) </code>
</li><li><code> unsigned short WMRedComponentOfColor (WMColor *color) </code>
</li><li><code> unsigned short WMGreenComponentOfColor (WMColor *color) </code>
</li><li><code> void WMSetColorInGC (WMColor *color, GC gc) </code>
</li><li><code> WMPixel WMColorPixel (WMColor *color) </code>
</li><li><code> void WMSetColorAlpha (WMColor *color, unsigned short alpha) </code>
</li><li><code> unsigned short WMGetColorAlpha (WMColor *color) </code>
</li></ul><ul>
<li><code> void WMPaintColorSwatch (WMColor *color, Drawable d, int x, int y, unsigned int width, unsigned int height) </code>
</li><li><code> void WMSetColorWellColor (WMColorWell *cPtr, WMColor *color) </code>
</li><li><code> WMColorWell * WMCreateColorWell (WMWidget *parent) </code>
</li><li><code> WMColor * WMGetColorWellColor (WMColorWell *cPtr) </code>
</li></ul>


<h5>WMFont</h5>
<ul>
<li><code> WMFont * WMCreateFont (WMScreen *scrPtr, char *fontName) </code>
</li><li><code> WMFont * WMCreateFontSet (WMScreen *scrPtr, char *fontName) </code>
</li><li><code> WMFont * WMCreateFontWithFlags (WMScreen *scrPtr, char *fontName, WMFontFlags flags) </code>
</li><li><code> WMFont * WMCreateNormalFont (WMScreen *scrPtr, char *fontName) </code>
</li><li><code> WMFont * WMCreateAntialiasedFont (WMScreen *scrPtr, char *fontName) </code>
</li><li><code> WMFont * WMCreateAntialiasedFontSet (WMScreen *scrPtr, char *fontName) </code>
</li><li><code> WMFont * WMCopyFontWithChanges (WMScreen *scrPtr, WMFont *font, const WMFontAttributes *changes) </code>
</li><li><code> void WMReleaseFont (WMFont *font) </code>
</li><li><code> WMFont * WMRetainFont (WMFont *font) </code>
</li><li><code> WMFont * WMDefaultBoldSystemFont (WMScreen *scrPtr) </code>
</li><li><code> WMFont * WMDefaultSystemFont (WMScreen *scrPtr) </code>
</li><li><code> WMFont * WMSystemFontOfSize (WMScreen *scrPtr, int size) </code>
</li><li><code> WMFont * WMBoldSystemFontOfSize (WMScreen *scrPtr, int size) </code>
</li><li><code> unsigned int WMFontHeight (WMFont *font) </code>
</li><li><code> XFontSet WMGetFontFontSet (WMFont *font) </code>
</li><li><code> char * WMGetFontName (WMFont *font) </code>
</li><li><code> Bool WMIsAntialiasedFont (WMFont *font) </code>
</li><li><code> void WMSetWidgetDefaultBoldFont (WMScreen *scr, WMFont *font) </code>
</li><li><code> void WMSetWidgetDefaultFont (WMScreen *scr, WMFont *font) </code>
</li></ul>


<h5>WMArray</h5>
<ul>
<li><code> WMArray * WMCreateArray (int initialSize) </code>
</li><li><code> WMArray * WMCreateArrayWithArray (WMArray *array) </code>
</li><li><code> WMArray * WMCreateArrayWithDestructor (int initialSize, WMFreeDataProc *destructor) </code>

</li><li><code> void WMAddToArray (WMArray *array, void *item) </code>
</li><li><code> void WMAppendArray (WMArray *array, WMArray *other) </code>
</li><li><code> void * WMArrayFirst (WMArray *array, WMArrayIterator *iter) </code>
</li><li><code> void * WMArrayLast (WMArray *array, WMArrayIterator *iter) </code>
</li><li><code> void * WMArrayNext (WMArray *array, WMArrayIterator *iter) </code>
</li><li><code> void * WMArrayPrevious (WMArray *array, WMArrayIterator *iter) </code>
</li><li><code> int WMCountInArray (WMArray *array, void *item) </code>
</li><li><code> int WMDeleteFromArray (WMArray *array, int index) </code>
</li><li><code> void WMEmptyArray (WMArray *array) </code>
</li><li><code> int WMFindInArray (WMArray *array, WMMatchDataProc *match, void *cdata) </code>
</li><li><code> void WMFreeArray (WMArray *array) </code>
</li><li><code> int WMGetArrayItemCount (WMArray *array) </code>
</li><li><code> void * WMGetFromArray (WMArray *array, int index) </code>
</li><li><code> void WMInsertInArray (WMArray *array, int index, void *item) </code>
</li><li><code> void WMMapArray (WMArray *array, void (*function)(void *, void *), void *data) </code>
</li><li><code> void * WMPopFromArray (WMArray *array) </code>
</li><li><code> int WMRemoveFromArrayMatching (WMArray *array, WMMatchDataProc *match, void *cdata) </code>
</li><li><code> void * WMReplaceInArray (WMArray *array, int index, void *item) </code>
</li><li><code> void WMSortArray (WMArray *array, WMCompareDataProc *comparer) </code>
</li></ul><ul>

<li><code> WMPropList * WMCreatePLArray (WMPropList *elem, ... ) </code>
</li><li><code> void WMAddToPLArray (WMPropList *plist, WMPropList *item) </code>
</li><li><code> void WMDeleteFromPLArray (WMPropList *plist, int index) </code>
</li><li><code> WMPropList * WMGetFromPLArray (WMPropList *plist, int index) </code>
</li><li><code> void WMInsertInPLArray (WMPropList *plist, int index, WMPropList *item) </code>
</li><li><code> Bool WMIsPLArray (WMPropList *plist) </code>
</li><li><code> void WMRemoveFromPLArray (WMPropList *plist, WMPropList *item) </code>
</li><li><code>WM_ITERATE_ARRAY(WMArray *,itemtype *,WMArrayIterator *iter)</code>
</li></ul>


<h5>Trees</h5>
<ul>

<li><code> WMTreeNode * WMCreateTreeNode (void *data) </code>
</li><li><code> WMTreeNode * WMCreateTreeNodeWithDestructor (void *data, WMFreeDataProc *destructor) </code>
</li><li><code> void WMDeleteLeafForTreeNode (WMTreeNode *aNode, int index) </code>
</li><li><code> void WMDestroyTreeNode (WMTreeNode *aNode) </code>
</li><li><code> void * WMGetDataForTreeNode (WMTreeNode *aNode) </code>
</li><li><code> void * WMReplaceDataForTreeNode (WMTreeNode *aNode, void *newData) </code>
</li><li><code> WMTreeNode * WMGetParentForTreeNode (WMTreeNode *aNode) </code>
</li><li><code> int WMGetTreeNodeDepth (WMTreeNode *aNode) </code>
</li><li><code> WMTreeNode * WMFindInTree (WMTreeNode *aTree, WMMatchDataProc *match, void *cdata) </code>
</li><li><code> WMTreeNode * WMInsertItemInTree (WMTreeNode *parent, int index, void *item) </code>
</li><li><code> WMTreeNode * WMInsertNodeInTree (WMTreeNode *parent, int index, WMTreeNode *aNode) </code>
</li><li><code> void WMRemoveLeafForTreeNode (WMTreeNode *aNode, void *leaf) </code>
</li><li><code> void WMSortLeavesForTreeNode (WMTreeNode *aNode, WMCompareDataProc *comparer) </code>
</li><li><code> void WMSortTree (WMTreeNode *aNode, WMCompareDataProc *comparer) </code>

</li></ul>


<h3>ENUMS and #defines</h3>

<h5><a name="EventsList">List</a> of event masks and corresponding events</h5>


<table><tbody><tr><th>Event mask</th><th>Event</th>
</tr><tr><td><code>KeyPressMask </code></td><td><code> KeyPress </code></td>
</tr><tr><td><code>KeyReleaseMask </code></td><td><code> KeyRelease </code></td>
</tr><tr><td><code>ButtonPressMask </code></td><td><code> ButtonPress </code></td>
</tr><tr><td><code>ButtonReleaseMask </code></td><td><code> ButtonRelease </code></td>
</tr><tr><td><code>EnterWindowMask </code></td><td><code> EnterNotify </code></td>
</tr><tr><td><code>LeaveWindowMask </code></td><td><code> LeaveNotify </code></td>
</tr><tr><td><code>FocusChangeMask </code></td><td><code> FocusIn </code></td>
</tr><tr><td><code>FocusChangeMask </code></td><td><code> FocusOut </code></td>
</tr><tr><td><code>KeymapStateMask </code></td><td><code> KeymapNotify </code></td>
</tr><tr><td><code>ExposureMask </code></td><td><code> Expose </code></td>
</tr><tr><td><code>ExposureMask </code></td><td><code> GraphicsExpose </code></td>
</tr><tr><td><code>ExposureMask </code></td><td><code> NoExpose </code></td>
</tr><tr><td><code>VisibilityChangeMask </code></td><td><code> VisibilityNotify </code></td>
</tr><tr><td><code>SubstructureNotifyMask </code></td><td><code> CreateNotify </code></td>
</tr><tr><td><code>StructureNotifyMask </code></td><td><code> DestroyNotify </code></td>
</tr><tr><td><code>StructureNotifyMask </code></td><td><code> UnmapNotify </code></td>
</tr><tr><td><code>StructureNotifyMask </code></td><td><code> MapNotify </code></td>
</tr><tr><td><code>SubstructureRedirectMask </code></td><td><code> MapRequest </code></td>
</tr><tr><td><code>StructureNotifyMask </code></td><td><code> ReparentNotify </code></td>
</tr><tr><td><code>StructureNotifyMask </code></td><td><code> ConfigureNotify </code></td>
</tr><tr><td><code>SubstructureRedirectMask </code></td><td><code> ConfigureRequest </code></td>
</tr><tr><td><code>StructureNotifyMask </code></td><td><code> GravityNotify </code></td>
</tr><tr><td><code>ResizeRedirectMask </code></td><td><code> ResizeRequest </code></td>
</tr><tr><td><code>StructureNotifyMask </code></td><td><code> CirculateNotify </code></td>
</tr><tr><td><code>SubstructureRedirectMask </code></td><td><code> CirculateRequest </code></td>
</tr><tr><td><code>PropertyChangeMask </code></td><td><code> PropertyNotify </code></td>
</tr><tr><td><code>ColormapChangeMask </code></td><td><code> ColormapNotify </code></td>
</tr><tr><td><code>ClientMessageMask</code></td><td><code> ClientMessage </code></td>
</tr><tr><td><code>PointerMotionMask|PointerMotionHintMask|<br>
ButtonMotionMask|Button1MotionMask|<br>
Button2MotionMask|Button3MotionMask|<br>
Button4MotionMask|Button5MotionMask</code></td><td><code> MotionNotify </code></td>

</tr></tbody></table>


<h5><a name="TitlePositions"> Frame Title Positions</a> </h5>
<ul>
<li><code>    WTPAboveTop<code>
</code></code></li><li><code><code><code>         WTPAtTop</code>
 </code></code></li><li><code><code><code>        WTPBelowTop</code>
 </code></code></li><li><code><code><code>        WTPAboveBottom</code>
 </code></code></li><li><code><code><code>        WTPAtBottom</code>
 </code></code></li><li><code><code><code>        WTPBelowBottom</code>
</code></code></li></ul><code><code>
<h5><a name="ImagePositions"> WM Image Positions</a> <code>WMImagePosition</code> </h5>
<ul>
<li><code>  WIPNoImage,
</code></li><li><code><code>WIPImageOnly,
</code></code></li><li><code><code><code>WIPLeft,
</code></code></code></li><li><code><code><code><code>WIPRight,
</code></code></code></code></li><li><code><code><code><code><code>WIPBelow,
</code></code></code></code></code></li><li><code><code><code><code><code><code>WIPAbove,
</code></code></code></code></code></code></li><li><code><code><code><code><code><code><code>WIPOverlaps
</code></code></code></code></code></code></code></li></ul><code><code><code><code><code><code><code>
<h5><a name="Alignment"> WMAlignment</a> </h5>
<ul>
 <li><code>  WALeft
 </code></li><li><code><code>   WACenter
  </code></code></li><li><code><code><code>  WARight
 </code></code></code></li><li><code><code><code><code>   WAJustified</code>
</code></code></code></li></ul><code><code><code>

<h5><a name="relief">Reliefs <code>WMReliefType</code></a></h5><a name="relief">
<ul>
  <li><code>    WRFlat</code>
  </li><li><code>    WRSimple</code>
   </li><li><code>   WRRaised</code>
 </li><li><code>     WRSunken</code>
   </li><li><code>   WRGroove</code>
   </li><li><code>   WRRidge</code>
 </li><li><code>     WRPushed</code>
</li></ul>
<h5>Colours</h5>
<p><code>
typedef struct RColor {
    unsigned char red;
    unsigned char green;
    unsigned char blue;
    unsigned char alpha;
} RColor;
</code>

</p><p><code>
typedef struct RSegment {
    int x1, y1, x2, y2;
} RSegment;
</code>


<br>
<br>
</p><p>
</p><table align="JUSTIFY" width="100%"><tbody><tr><td align="LEFT"><a href="WINGMenu.html">LAST: Programming Details 3</a></td><td align="RIGHT"><a href="WINGtoc.html">Contents</a></td></tr></tbody></table>



<!--  W_VIEW_REALIZED W_VIEW_DISPLAY  W_VIEW_DRAWABLE  resp. flag, display, window of type Window -->
<!-- view->childrenList, view->parent view->pos.x  view->screen  -->
</a></code></code></code></code></code></code></code></code></code></code></code></code></code></li></ul<li></body><style type="text/css">embed[type*="application/x-shockwave-flash"],embed[src*=".swf"],object[type*="application/x-shockwave-flash"],object[codetype*="application/x-shockwave-flash"],object[src*=".swf"],object[codebase*="swflash.cab"],object[classid*="D27CDB6E-AE6D-11cf-96B8-444553540000"],object[classid*="d27cdb6e-ae6d-11cf-96b8-444553540000"],object[classid*="D27CDB6E-AE6D-11cf-96B8-444553540000"]{	display: none !important;}</style></html>